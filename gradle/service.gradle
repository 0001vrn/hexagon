/*
 * For more details about this build script, check the `site/content/life_cycle.md` file.
 */

apply plugin: 'application'

defaultTasks 'install'

processResources.dependsOn 'buildInfo'

// Add configuration file with build variables to the package
task buildInfo {
    doLast {
        file ("$buildDir/resources/main").mkdirs ()
        file ("$buildDir/resources/main/service.properties").write """
        project=$rootProject.name
        module=$project.name
        version=${project.version.toString()}
        group=$project.group
        description=$project.description
        """.stripIndent ()
    }
}

installDist.dependsOn 'check'

// Include 'Systemd' script to execute the service as an UNIX service
task install(dependsOn: 'installDist') {
    doLast {
        String deployDir = findProperty ('deployDir') ?: '/opt'
        String serviceUser = findProperty ('serviceUser') ?: 'root'
        String serviceGroup = findProperty ('serviceGroup') ?: serviceUser

        Map<String, String> parameters = [
            projectName : project.name,
            projectVersion : project.version.toString(),
            projectGroup : project.group.toString (),
            projectDescription : project.description,
            deployDir : deployDir,
            serviceUser : serviceUser,
            serviceGroup : serviceGroup
        ]

        String content = new URL("$gradleScripts/systemdService").text
        parameters.each { content = content.replace ('${' + it.key + '}', it.value) }
        File script = file ("${tasks.installDist.destinationDir}/bin/${project.name}.service")
        script.write content
    }
}

// Run the service in another thread. This allow the possibility to 'watch' source changes
task runService(dependsOn: 'classes') {
    doLast {
        // NOTE: these two statements are required to load classpath and main class
        run.classpath.each { it.toString() }
        run.main.toString()

        ByteArrayOutputStream out = new ByteArrayOutputStream()
        exec {
            commandLine 'jps', '-l'
            standardOutput = out
        }
        out.toString ().readLines()
            .findAll { it.endsWith run.main }
            .collect { it.split(' ')[0] }
            .each { pid -> exec { commandLine 'kill', pid } }

        Thread.startDaemon {
            run.ignoreExitValue = true
            run.actions.each { action -> action.execute(run) }
        }
    }
}
