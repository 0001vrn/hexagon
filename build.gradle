/*
 * Main build script, responsible for:
 *
 *  1. Publishing: upload binaries and templates to Bintray
 *  2. Releasing: tag source code in GitHub
 *  3. Coverage report: aggregated coverage report for all modules
 *  4. Group all tasks: shortcut for all tasks to ease the release process
 *
 * Plugins that are not used in the root project (this one) are only applied by the modules that use
 * them.
 */

plugins {
    id "idea"
    id "eclipse"
    id "java"
    id "jacoco"

    id "org.sonarqube" version "2.8"
    id "org.jetbrains.kotlin.jvm" version "1.3.61" apply false
    id "org.jetbrains.dokka" version "0.10.0" apply false
    id "com.jfrog.bintray" version "1.8.4" apply false
    id "uk.co.cacoethes.lazybones-templates" version "1.2.3" apply false
}

apply(from: "gradle/sonarqube.gradle")
apply(from: "gradle/ssl.gradle")

repositories {
    jcenter() // Repository required by Jacoco Report
}

clean {
    delete("build", "log", "out", ".vertx", "file-uploads")

    delete(
        fileTree(rootDir) { include "**/*.log" },
        fileTree(rootDir) { include "**/*.hprof" },
        fileTree(rootDir) { include "**/.attach_pid*" },
        fileTree(rootDir) { include "**/hs_err_pid*" }
    )
}

task("publish", dependsOn:
    project.getTasksByName("bintrayUpload", true) +
    tasks.getByPath(":hexagon_starters:publishAllTemplates")
)

task("release", dependsOn: "publish") {
    doLast {
        exec { commandLine("git", "tag", "-m", "Release $version".toString(), version) }
        exec { commandLine("git", "push", "--tags") }
    }
}

task("jacocoMerge", type: JacocoMerge) {
    destinationFile = file("${rootProject.buildDir}/jacoco/allTest.exec")
    executionData = project.fileTree(dir: ".", include: "**/build/jacoco/test.exec")
}

task(
    "jacocoReport",
    type: JacocoReport,
    dependsOn: getTasksByName("jacocoTestReport", true) + getTasksByName("jacocoMerge", false)) {

    final String rootPath = rootDir.absolutePath
    final String execPattern = "**/build/jacoco/test.exec"
    executionData.setFrom(fileTree(rootPath).include(execPattern))

    subprojects.each {
        sourceSets(it.sourceSets.main as SourceSet)
    }

    reports {
        html.enabled = true
        xml.enabled = true
    }
}

project.tasks["sonarqube"].dependsOn("jacocoReport")

childProjects.each { pair ->
    final String name = pair.key
    final Project prj = pair.value
    final boolean empty = prj.getTasksByName("dokkaMd", false)?.isEmpty() ?: true
    final siteContentPath = "${rootDir}/hexagon_site/content"

    if (!(name in ["hexagon_benchmark", "hexagon_site", "hexagon_starters"]) && empty) {
        project(name) {
            task("dokkaBase", type: org.jetbrains.dokka.gradle.DokkaTask) {
                outputFormat = "gfm"
                outputDirectory = siteContentPath

                configuration {
                    reportUndocumented = false
                    includes = filesCollection(prj.projectDir, "*.md")
                    samples = filesCollection(
                        "${prj.projectDir}/src/test/kotlin",
                        "**/*SamplesTest.kt"
                    )
                    sourceRoot { path = "$projectDir/src/main/kotlin" }
                }
            }

            task("dokkaMd", dependsOn: "dokkaBase") {
                doLast {
                    addMetadata(siteContentPath, prj)
                }
            }
        }
    }
}

task("all", dependsOn:
    project.getTasksByName("build", true) +
    project.getTasksByName("jacocoReport", true) +
    project.getTasksByName("installDist", true) +
    project.getTasksByName("installAllTemplates", true) +
    project.getTasksByName("publishToMavenLocal", true) +
    project.getTasksByName("createIdentity", true) +
    project.getTasksByName("tfb", true)
)

private List<String> filesCollection(final Object dir, final String pattern) {
    return fileTree(dir: dir, include: pattern).getFiles().toList().collect { it.absolutePath }
}

private void addMetadata(final String siteContentPath, final Project project) {
    String projectDirName = project.projectDir.name
    filesCollection(siteContentPath, "**/${projectDirName}/**/*.md").each {
        File md = new File(it)
        File tempFile = File.createTempFile("temp", md.name)
        tempFile.withWriter { writer ->
            writer.writeLine toEditUrl(it, siteContentPath, projectDirName)
            md.withInputStream { stream ->
                stream.eachLine { line ->
                    writer.writeLine line
                }
            }
        }
        ant.move(file: tempFile, tofile: md)
    }
}

private String toEditUrl(
    final String mdPath, final String siteContentPath, final String projectDirName) {

    final String prefix = "edit_url: edit/master/${projectDirName}"
    final String withoutContentPath = mdPath.minus("${siteContentPath}/${projectDirName}/")
    final String[] parts = withoutContentPath.split(File.separator)

    String editUrl = ""

    if (parts.size() > 1 && withoutContentPath.startsWith("com.hexagon")) {
        String afterPackage = parts[1]
        if (!afterPackage.contains('test')) {
            String srcPrefix = "${prefix}/src/main/kotlin"
            String packageName = parts[0].replace('.', '/')

            if (afterPackage == "index.md") {
                editUrl = "${srcPrefix}/${packageName}/package-info.java"
            } else if (afterPackage.endsWith(".md") || afterPackage.contains(".")) {
                String lastPath = packageName.split('/')?.last()

                editUrl = "${srcPrefix}/${packageName}/${lastPath.capitalize()}.kt"
            } else {
                String className = toClassName(afterPackage)

                editUrl = "${srcPrefix}/${packageName}/${className}.kt"
            }
        }
    } else if (withoutContentPath == "index.md") {
        editUrl = "${prefix}/README.md"
    }

    return editUrl
}

private String toClassName(final String mdClassName) {
    mdClassName.replaceAll("\\-[a-z][a-z]*", { it -> it[1].toUpperCase() + it.substring(2) })
}
